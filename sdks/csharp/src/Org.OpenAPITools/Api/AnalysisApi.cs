/* 
 * MetaDefender Core
 *
 * ## Developer Guide This is the API documentation for *MetaDefender Core Public API*.  If you would like to evaluate or have any questions about this documentation, please contact us via our [Contact Us](https://opswat.com/contact) form.  ## How to Interact with MetaDefender Core using REST Beginning with MetaDefender Core 4.x, OPSWAT recommends using the JSON-based REST API. The available methods are documented below. > _**Note**:_ MetaDefender API doesn't support chunk upload, however is recommended to stream the files to MetaDefender as part of the upload process.  - -- ## File Analysis Process    MetaDefender's main functionality is to analyze large volumes with a high throughput. Depending on the configuration and licensed technologies, the analysis times can vary.    Below is a brief description of the API integration flow:    1. Upload a file for analysis (`POST /file`), which returns the `data_id`: [File Analysis](#operation/fileAnalysisPost)).           > _**Note**:_ The performance depends on:           > - number of nodes (scaling)     > - number of engines per node     > - type of file to be scanned     > - Metadefender Core and nodes' hardware       2. You have 2 ways to retrieve the analysis report:      - **Polling**: Fetch the result with previously received data_id (`GET /file/{data_id}` resource) until scan result belonging to data_id doesn't reach the 100 percent progress_percentage: ( [Fetch processing result](#operation/userLogin))        > _**Note**:_ Too many data_id requests can reduce performance. It is enough to just check every few hundred milliseconds.          - **Callbackurl**: Specify a callbackurl that will be called once the analysis is complete.     3. Retrieve the analysis results anytime after the analysis is completed with hash for files (md5, sha1, sha256) by calling [Fetch processing result](#operation/userLogin).      - The hash can be found in the scan results    4. Retrieve processed file (sanitized, redacted, watermarked, etc.) after the analysis is complete.      > _**Note**:_ Based on the configured retention policy, the files might be available for retrieval at a later time.   - -- OPSWAT provides some sample codes on [GitHub](https://github.com/OPSWAT) to make it easier to understand how the MetaDefender REST API works. 
 *
 * The version of the OpenAPI document: v4.18.0
 * Contact: feedback@opswat.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAnalysisApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Fetching Available Analysis Rules
        /// </summary>
        /// <remarks>
        /// Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>List&lt;InlineResponse20010&gt;</returns>
        List<InlineResponse20010> AnalysisRules (string userAgent = default(string));

        /// <summary>
        /// Fetching Available Analysis Rules
        /// </summary>
        /// <remarks>
        /// Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>ApiResponse of List&lt;InlineResponse20010&gt;</returns>
        ApiResponse<List<InlineResponse20010>> AnalysisRulesWithHttpInfo (string userAgent = default(string));
        /// <summary>
        /// Cancel File Analysis
        /// </summary>
        /// <remarks>
        /// When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Object</returns>
        Object FileAnalysisCancel (string dataId, string apikey = default(string));

        /// <summary>
        /// Cancel File Analysis
        /// </summary>
        /// <remarks>
        /// When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> FileAnalysisCancelWithHttpInfo (string dataId, string apikey = default(string));
        /// <summary>
        /// Fetch Analysis Result
        /// </summary>
        /// <remarks>
        /// Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>AnalysisResult</returns>
        AnalysisResult FileAnalysisGet (string dataId, string apikey = default(string));

        /// <summary>
        /// Fetch Analysis Result
        /// </summary>
        /// <remarks>
        /// Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of AnalysisResult</returns>
        ApiResponse<AnalysisResult> FileAnalysisGetWithHttpInfo (string dataId, string apikey = default(string));
        /// <summary>
        /// Analyze File
        /// </summary>
        /// <remarks>
        /// ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>InlineResponse2008</returns>
        InlineResponse2008 FileAnalysisPost (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream));

        /// <summary>
        /// Analyze File
        /// </summary>
        /// <remarks>
        /// ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        ApiResponse<InlineResponse2008> FileAnalysisPostWithHttpInfo (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream));
        /// <summary>
        /// Download Sanitized Files
        /// </summary>
        /// <remarks>
        /// Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>System.IO.Stream</returns>
        System.IO.Stream SanitizedFile (string dataId, string apikey = default(string));

        /// <summary>
        /// Download Sanitized Files
        /// </summary>
        /// <remarks>
        /// Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        ApiResponse<System.IO.Stream> SanitizedFileWithHttpInfo (string dataId, string apikey = default(string));
        /// <summary>
        /// Query webhook status
        /// </summary>
        /// <remarks>
        /// Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>InlineResponse2009</returns>
        InlineResponse2009 WebhookStatus (string dataId, string apikey = default(string));

        /// <summary>
        /// Query webhook status
        /// </summary>
        /// <remarks>
        /// Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of InlineResponse2009</returns>
        ApiResponse<InlineResponse2009> WebhookStatusWithHttpInfo (string dataId, string apikey = default(string));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Fetching Available Analysis Rules
        /// </summary>
        /// <remarks>
        /// Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>Task of List&lt;InlineResponse20010&gt;</returns>
        System.Threading.Tasks.Task<List<InlineResponse20010>> AnalysisRulesAsync (string userAgent = default(string));

        /// <summary>
        /// Fetching Available Analysis Rules
        /// </summary>
        /// <remarks>
        /// Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;InlineResponse20010&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<InlineResponse20010>>> AnalysisRulesAsyncWithHttpInfo (string userAgent = default(string));
        /// <summary>
        /// Cancel File Analysis
        /// </summary>
        /// <remarks>
        /// When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> FileAnalysisCancelAsync (string dataId, string apikey = default(string));

        /// <summary>
        /// Cancel File Analysis
        /// </summary>
        /// <remarks>
        /// When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FileAnalysisCancelAsyncWithHttpInfo (string dataId, string apikey = default(string));
        /// <summary>
        /// Fetch Analysis Result
        /// </summary>
        /// <remarks>
        /// Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of AnalysisResult</returns>
        System.Threading.Tasks.Task<AnalysisResult> FileAnalysisGetAsync (string dataId, string apikey = default(string));

        /// <summary>
        /// Fetch Analysis Result
        /// </summary>
        /// <remarks>
        /// Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (AnalysisResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<AnalysisResult>> FileAnalysisGetAsyncWithHttpInfo (string dataId, string apikey = default(string));
        /// <summary>
        /// Analyze File
        /// </summary>
        /// <remarks>
        /// ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of InlineResponse2008</returns>
        System.Threading.Tasks.Task<InlineResponse2008> FileAnalysisPostAsync (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream));

        /// <summary>
        /// Analyze File
        /// </summary>
        /// <remarks>
        /// ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> FileAnalysisPostAsyncWithHttpInfo (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream));
        /// <summary>
        /// Download Sanitized Files
        /// </summary>
        /// <remarks>
        /// Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of System.IO.Stream</returns>
        System.Threading.Tasks.Task<System.IO.Stream> SanitizedFileAsync (string dataId, string apikey = default(string));

        /// <summary>
        /// Download Sanitized Files
        /// </summary>
        /// <remarks>
        /// Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        System.Threading.Tasks.Task<ApiResponse<System.IO.Stream>> SanitizedFileAsyncWithHttpInfo (string dataId, string apikey = default(string));
        /// <summary>
        /// Query webhook status
        /// </summary>
        /// <remarks>
        /// Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of InlineResponse2009</returns>
        System.Threading.Tasks.Task<InlineResponse2009> WebhookStatusAsync (string dataId, string apikey = default(string));

        /// <summary>
        /// Query webhook status
        /// </summary>
        /// <remarks>
        /// Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2009)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2009>> WebhookStatusAsyncWithHttpInfo (string dataId, string apikey = default(string));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class AnalysisApi : IAnalysisApi
    {
        private Org.OpenAPITools.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="AnalysisApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AnalysisApi(String basePath)
        {
            this.Configuration = new Org.OpenAPITools.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AnalysisApi"/> class
        /// </summary>
        /// <returns></returns>
        public AnalysisApi()
        {
            this.Configuration = Org.OpenAPITools.Client.Configuration.Default;

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AnalysisApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public AnalysisApi(Org.OpenAPITools.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Org.OpenAPITools.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.OpenAPITools.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.OpenAPITools.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Fetching Available Analysis Rules Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>List&lt;InlineResponse20010&gt;</returns>
        public List<InlineResponse20010> AnalysisRules (string userAgent = default(string))
        {
             ApiResponse<List<InlineResponse20010>> localVarResponse = AnalysisRulesWithHttpInfo(userAgent);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Fetching Available Analysis Rules Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>ApiResponse of List&lt;InlineResponse20010&gt;</returns>
        public ApiResponse<List<InlineResponse20010>> AnalysisRulesWithHttpInfo (string userAgent = default(string))
        {

            var localVarPath = "/file/rules";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userAgent != null) localVarHeaderParams.Add("user_agent", this.Configuration.ApiClient.ParameterToString(userAgent)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AnalysisRules", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<InlineResponse20010>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<InlineResponse20010>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<InlineResponse20010>)));
        }

        /// <summary>
        /// Fetching Available Analysis Rules Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>Task of List&lt;InlineResponse20010&gt;</returns>
        public async System.Threading.Tasks.Task<List<InlineResponse20010>> AnalysisRulesAsync (string userAgent = default(string))
        {
             ApiResponse<List<InlineResponse20010>> localVarResponse = await AnalysisRulesAsyncWithHttpInfo(userAgent);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Fetching Available Analysis Rules Retrieve all available rules with their custom configurations. Fetching available processing rules. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userAgent">The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;InlineResponse20010&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<InlineResponse20010>>> AnalysisRulesAsyncWithHttpInfo (string userAgent = default(string))
        {

            var localVarPath = "/file/rules";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userAgent != null) localVarHeaderParams.Add("user_agent", this.Configuration.ApiClient.ParameterToString(userAgent)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AnalysisRules", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<InlineResponse20010>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<InlineResponse20010>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<InlineResponse20010>)));
        }

        /// <summary>
        /// Cancel File Analysis When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Object</returns>
        public Object FileAnalysisCancel (string dataId, string apikey = default(string))
        {
             ApiResponse<Object> localVarResponse = FileAnalysisCancelWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel File Analysis When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of Object</returns>
        public ApiResponse<Object> FileAnalysisCancelWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->FileAnalysisCancel");

            var localVarPath = "/file/{data_id}/cancel";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FileAnalysisCancel", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Object) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Object)));
        }

        /// <summary>
        /// Cancel File Analysis When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> FileAnalysisCancelAsync (string dataId, string apikey = default(string))
        {
             ApiResponse<Object> localVarResponse = await FileAnalysisCancelAsyncWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel File Analysis When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FileAnalysisCancelAsyncWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->FileAnalysisCancel");

            var localVarPath = "/file/{data_id}/cancel";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FileAnalysisCancel", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Object) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Object)));
        }

        /// <summary>
        /// Fetch Analysis Result Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>AnalysisResult</returns>
        public AnalysisResult FileAnalysisGet (string dataId, string apikey = default(string))
        {
             ApiResponse<AnalysisResult> localVarResponse = FileAnalysisGetWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch Analysis Result Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of AnalysisResult</returns>
        public ApiResponse<AnalysisResult> FileAnalysisGetWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->FileAnalysisGet");

            var localVarPath = "/file/{data_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FileAnalysisGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnalysisResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AnalysisResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnalysisResult)));
        }

        /// <summary>
        /// Fetch Analysis Result Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of AnalysisResult</returns>
        public async System.Threading.Tasks.Task<AnalysisResult> FileAnalysisGetAsync (string dataId, string apikey = default(string))
        {
             ApiResponse<AnalysisResult> localVarResponse = await FileAnalysisGetAsyncWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Fetch Analysis Result Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId"></param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (AnalysisResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AnalysisResult>> FileAnalysisGetAsyncWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->FileAnalysisGet");

            var localVarPath = "/file/{data_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FileAnalysisGet", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnalysisResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AnalysisResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnalysisResult)));
        }

        /// <summary>
        /// Analyze File ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>InlineResponse2008</returns>
        public InlineResponse2008 FileAnalysisPost (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream))
        {
             ApiResponse<InlineResponse2008> localVarResponse = FileAnalysisPostWithHttpInfo(apikey, filename, filepath, userAgent, rule, workflow, batch, archivepwd, metadata, callbackurl, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Analyze File ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        public ApiResponse<InlineResponse2008> FileAnalysisPostWithHttpInfo (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream))
        {

            var localVarPath = "/file";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/octet-stream"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter
            if (filename != null) localVarHeaderParams.Add("filename", this.Configuration.ApiClient.ParameterToString(filename)); // header parameter
            if (filepath != null) localVarHeaderParams.Add("filepath", this.Configuration.ApiClient.ParameterToString(filepath)); // header parameter
            if (userAgent != null) localVarHeaderParams.Add("user_agent", this.Configuration.ApiClient.ParameterToString(userAgent)); // header parameter
            if (rule != null) localVarHeaderParams.Add("rule", this.Configuration.ApiClient.ParameterToString(rule)); // header parameter
            if (workflow != null) localVarHeaderParams.Add("workflow", this.Configuration.ApiClient.ParameterToString(workflow)); // header parameter
            if (batch != null) localVarHeaderParams.Add("batch", this.Configuration.ApiClient.ParameterToString(batch)); // header parameter
            if (archivepwd != null) localVarHeaderParams.Add("archivepwd", this.Configuration.ApiClient.ParameterToString(archivepwd)); // header parameter
            if (metadata != null) localVarHeaderParams.Add("metadata", this.Configuration.ApiClient.ParameterToString(metadata)); // header parameter
            if (callbackurl != null) localVarHeaderParams.Add("callbackurl", this.Configuration.ApiClient.ParameterToString(callbackurl)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FileAnalysisPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2008>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2008) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2008)));
        }

        /// <summary>
        /// Analyze File ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of InlineResponse2008</returns>
        public async System.Threading.Tasks.Task<InlineResponse2008> FileAnalysisPostAsync (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream))
        {
             ApiResponse<InlineResponse2008> localVarResponse = await FileAnalysisPostAsyncWithHttpInfo(apikey, filename, filepath, userAgent, rule, workflow, batch, archivepwd, metadata, callbackurl, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Analyze File ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <param name="filename">The name of the submitted file (optional)</param>
        /// <param name="filepath">if local file scan is enabled the path to the file (see Security rule configuration) (optional)</param>
        /// <param name="userAgent">user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)</param>
        /// <param name="rule">Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)</param>
        /// <param name="workflow">name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)</param>
        /// <param name="batch">Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)</param>
        /// <param name="archivepwd">password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)</param>
        /// <param name="metadata">could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)</param>
        /// <param name="callbackurl">Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> FileAnalysisPostAsyncWithHttpInfo (string apikey = default(string), string filename = default(string), string filepath = default(string), string userAgent = default(string), string rule = default(string), string workflow = default(string), string batch = default(string), string archivepwd = default(string), string metadata = default(string), string callbackurl = default(string), System.IO.Stream body = default(System.IO.Stream))
        {

            var localVarPath = "/file";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/octet-stream"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter
            if (filename != null) localVarHeaderParams.Add("filename", this.Configuration.ApiClient.ParameterToString(filename)); // header parameter
            if (filepath != null) localVarHeaderParams.Add("filepath", this.Configuration.ApiClient.ParameterToString(filepath)); // header parameter
            if (userAgent != null) localVarHeaderParams.Add("user_agent", this.Configuration.ApiClient.ParameterToString(userAgent)); // header parameter
            if (rule != null) localVarHeaderParams.Add("rule", this.Configuration.ApiClient.ParameterToString(rule)); // header parameter
            if (workflow != null) localVarHeaderParams.Add("workflow", this.Configuration.ApiClient.ParameterToString(workflow)); // header parameter
            if (batch != null) localVarHeaderParams.Add("batch", this.Configuration.ApiClient.ParameterToString(batch)); // header parameter
            if (archivepwd != null) localVarHeaderParams.Add("archivepwd", this.Configuration.ApiClient.ParameterToString(archivepwd)); // header parameter
            if (metadata != null) localVarHeaderParams.Add("metadata", this.Configuration.ApiClient.ParameterToString(metadata)); // header parameter
            if (callbackurl != null) localVarHeaderParams.Add("callbackurl", this.Configuration.ApiClient.ParameterToString(callbackurl)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FileAnalysisPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2008>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2008) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2008)));
        }

        /// <summary>
        /// Download Sanitized Files Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>System.IO.Stream</returns>
        public System.IO.Stream SanitizedFile (string dataId, string apikey = default(string))
        {
             ApiResponse<System.IO.Stream> localVarResponse = SanitizedFileWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Download Sanitized Files Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        public ApiResponse<System.IO.Stream> SanitizedFileWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->SanitizedFile");

            var localVarPath = "/file/converted/{data_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream",
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SanitizedFile", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<System.IO.Stream>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (System.IO.Stream) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(System.IO.Stream)));
        }

        /// <summary>
        /// Download Sanitized Files Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of System.IO.Stream</returns>
        public async System.Threading.Tasks.Task<System.IO.Stream> SanitizedFileAsync (string dataId, string apikey = default(string))
        {
             ApiResponse<System.IO.Stream> localVarResponse = await SanitizedFileAsyncWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Download Sanitized Files Retrieve sanitized file based on the &#x60;data_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<System.IO.Stream>> SanitizedFileAsyncWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->SanitizedFile");

            var localVarPath = "/file/converted/{data_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream",
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SanitizedFile", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<System.IO.Stream>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (System.IO.Stream) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(System.IO.Stream)));
        }

        /// <summary>
        /// Query webhook status Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>InlineResponse2009</returns>
        public InlineResponse2009 WebhookStatus (string dataId, string apikey = default(string))
        {
             ApiResponse<InlineResponse2009> localVarResponse = WebhookStatusWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query webhook status Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>ApiResponse of InlineResponse2009</returns>
        public ApiResponse<InlineResponse2009> WebhookStatusWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->WebhookStatus");

            var localVarPath = "/file/webhook/{data_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WebhookStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2009>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2009) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2009)));
        }

        /// <summary>
        /// Query webhook status Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of InlineResponse2009</returns>
        public async System.Threading.Tasks.Task<InlineResponse2009> WebhookStatusAsync (string dataId, string apikey = default(string))
        {
             ApiResponse<InlineResponse2009> localVarResponse = await WebhookStatusAsyncWithHttpInfo(dataId, apikey);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query webhook status Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="dataId">Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;.</param>
        /// <param name="apikey">Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2009)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2009>> WebhookStatusAsyncWithHttpInfo (string dataId, string apikey = default(string))
        {
            // verify the required parameter 'dataId' is set
            if (dataId == null)
                throw new ApiException(400, "Missing required parameter 'dataId' when calling AnalysisApi->WebhookStatus");

            var localVarPath = "/file/webhook/{data_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (dataId != null) localVarPathParams.Add("data_id", this.Configuration.ApiClient.ParameterToString(dataId)); // path parameter
            if (apikey != null) localVarHeaderParams.Add("apikey", this.Configuration.ApiClient.ParameterToString(apikey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("WebhookStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2009>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2009) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2009)));
        }

    }
}
