/**
 * MetaDefender Core
 * ## Developer Guide This is the API documentation for *MetaDefender Core Public API*.  If you would like to evaluate or have any questions about this documentation, please contact us via our [Contact Us](https://opswat.com/contact) form.  ## How to Interact with MetaDefender Core using REST Beginning with MetaDefender Core 4.x, OPSWAT recommends using the JSON-based REST API. The available methods are documented below. > _**Note**:_ MetaDefender API doesn't support chunk upload, however is recommended to stream the files to MetaDefender as part of the upload process.  --- ## File Analysis Process    MetaDefender's main functionality is to analyze large volumes with a high throughput. Depending on the configuration and licensed technologies, the analysis times can vary.    Below is a brief description of the API integration flow:    1. Upload a file for analysis (`POST /file`), which returns the `data_id`: [File Analysis](#operation/fileAnalysisPost)).           > _**Note**:_ The performance depends on:           > - number of nodes (scaling)     > - number of engines per node     > - type of file to be scanned     > - Metadefender Core and nodes' hardware       2. You have 2 ways to retrieve the analysis report:      - **Polling**: Fetch the result with previously received data_id (`GET /file/{data_id}` resource) until scan result belonging to data_id doesn't reach the 100 percent progress_percentage: ( [Fetch processing result](#operation/userLogin))        > _**Note**:_ Too many data_id requests can reduce performance. It is enough to just check every few hundred milliseconds.          - **Callbackurl**: Specify a callbackurl that will be called once the analysis is complete.     3. Retrieve the analysis results anytime after the analysis is completed with hash for files (md5, sha1, sha256) by calling [Fetch processing result](#operation/userLogin).      - The hash can be found in the scan results    4. Retrieve processed file (sanitized, redacted, watermarked, etc.) after the analysis is complete.      > _**Note**:_ Based on the configured retention policy, the files might be available for retrieval at a later time.   --- OPSWAT provides some sample codes on [GitHub](https://github.com/OPSWAT) to make it easier to understand how the MetaDefender REST API works. 
 *
 * The version of the OpenAPI document: v4.18.0
 * Contact: feedback@opswat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINewUserRoleRequest_rights.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINewUserRoleRequest_rights::OAINewUserRoleRequest_rights(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINewUserRoleRequest_rights::OAINewUserRoleRequest_rights() {
    this->initializeModel();
}

OAINewUserRoleRequest_rights::~OAINewUserRoleRequest_rights() {}

void OAINewUserRoleRequest_rights::initializeModel() {

    m_agents_isSet = false;
    m_agents_isValid = false;

    m_cert_isSet = false;
    m_cert_isValid = false;

    m_configlog_isSet = false;
    m_configlog_isValid = false;

    m_engines_isSet = false;
    m_engines_isValid = false;

    m_external_isSet = false;
    m_external_isValid = false;

    m_license_isSet = false;
    m_license_isValid = false;

    m_quarantine_isSet = false;
    m_quarantine_isValid = false;

    m_retention_isSet = false;
    m_retention_isValid = false;

    m_rule_isSet = false;
    m_rule_isValid = false;

    m_scan_isSet = false;
    m_scan_isValid = false;

    m_scanlog_isSet = false;
    m_scanlog_isValid = false;

    m_skip_isSet = false;
    m_skip_isValid = false;

    m_update_isSet = false;
    m_update_isValid = false;

    m_updatelog_isSet = false;
    m_updatelog_isValid = false;

    m_users_isSet = false;
    m_users_isValid = false;

    m_workflow_isSet = false;
    m_workflow_isValid = false;

    m_zone_isSet = false;
    m_zone_isValid = false;
}

void OAINewUserRoleRequest_rights::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINewUserRoleRequest_rights::fromJsonObject(QJsonObject json) {

    m_agents_isValid = ::OpenAPI::fromJsonValue(agents, json[QString("agents")]);
    m_agents_isSet = !json[QString("agents")].isNull() && m_agents_isValid;

    m_cert_isValid = ::OpenAPI::fromJsonValue(cert, json[QString("cert")]);
    m_cert_isSet = !json[QString("cert")].isNull() && m_cert_isValid;

    m_configlog_isValid = ::OpenAPI::fromJsonValue(configlog, json[QString("configlog")]);
    m_configlog_isSet = !json[QString("configlog")].isNull() && m_configlog_isValid;

    m_engines_isValid = ::OpenAPI::fromJsonValue(engines, json[QString("engines")]);
    m_engines_isSet = !json[QString("engines")].isNull() && m_engines_isValid;

    m_external_isValid = ::OpenAPI::fromJsonValue(external, json[QString("external")]);
    m_external_isSet = !json[QString("external")].isNull() && m_external_isValid;

    m_license_isValid = ::OpenAPI::fromJsonValue(license, json[QString("license")]);
    m_license_isSet = !json[QString("license")].isNull() && m_license_isValid;

    m_quarantine_isValid = ::OpenAPI::fromJsonValue(quarantine, json[QString("quarantine")]);
    m_quarantine_isSet = !json[QString("quarantine")].isNull() && m_quarantine_isValid;

    m_retention_isValid = ::OpenAPI::fromJsonValue(retention, json[QString("retention")]);
    m_retention_isSet = !json[QString("retention")].isNull() && m_retention_isValid;

    m_rule_isValid = ::OpenAPI::fromJsonValue(rule, json[QString("rule")]);
    m_rule_isSet = !json[QString("rule")].isNull() && m_rule_isValid;

    m_scan_isValid = ::OpenAPI::fromJsonValue(scan, json[QString("scan")]);
    m_scan_isSet = !json[QString("scan")].isNull() && m_scan_isValid;

    m_scanlog_isValid = ::OpenAPI::fromJsonValue(scanlog, json[QString("scanlog")]);
    m_scanlog_isSet = !json[QString("scanlog")].isNull() && m_scanlog_isValid;

    m_skip_isValid = ::OpenAPI::fromJsonValue(skip, json[QString("skip")]);
    m_skip_isSet = !json[QString("skip")].isNull() && m_skip_isValid;

    m_update_isValid = ::OpenAPI::fromJsonValue(update, json[QString("update")]);
    m_update_isSet = !json[QString("update")].isNull() && m_update_isValid;

    m_updatelog_isValid = ::OpenAPI::fromJsonValue(updatelog, json[QString("updatelog")]);
    m_updatelog_isSet = !json[QString("updatelog")].isNull() && m_updatelog_isValid;

    m_users_isValid = ::OpenAPI::fromJsonValue(users, json[QString("users")]);
    m_users_isSet = !json[QString("users")].isNull() && m_users_isValid;

    m_workflow_isValid = ::OpenAPI::fromJsonValue(workflow, json[QString("workflow")]);
    m_workflow_isSet = !json[QString("workflow")].isNull() && m_workflow_isValid;

    m_zone_isValid = ::OpenAPI::fromJsonValue(zone, json[QString("zone")]);
    m_zone_isSet = !json[QString("zone")].isNull() && m_zone_isValid;
}

QString OAINewUserRoleRequest_rights::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINewUserRoleRequest_rights::asJsonObject() const {
    QJsonObject obj;
    if (agents.isSet()) {
        obj.insert(QString("agents"), ::OpenAPI::toJsonValue(agents));
    }
    if (cert.isSet()) {
        obj.insert(QString("cert"), ::OpenAPI::toJsonValue(cert));
    }
    if (configlog.isSet()) {
        obj.insert(QString("configlog"), ::OpenAPI::toJsonValue(configlog));
    }
    if (engines.isSet()) {
        obj.insert(QString("engines"), ::OpenAPI::toJsonValue(engines));
    }
    if (external.isSet()) {
        obj.insert(QString("external"), ::OpenAPI::toJsonValue(external));
    }
    if (license.isSet()) {
        obj.insert(QString("license"), ::OpenAPI::toJsonValue(license));
    }
    if (quarantine.isSet()) {
        obj.insert(QString("quarantine"), ::OpenAPI::toJsonValue(quarantine));
    }
    if (retention.isSet()) {
        obj.insert(QString("retention"), ::OpenAPI::toJsonValue(retention));
    }
    if (rule.isSet()) {
        obj.insert(QString("rule"), ::OpenAPI::toJsonValue(rule));
    }
    if (scan.isSet()) {
        obj.insert(QString("scan"), ::OpenAPI::toJsonValue(scan));
    }
    if (scanlog.isSet()) {
        obj.insert(QString("scanlog"), ::OpenAPI::toJsonValue(scanlog));
    }
    if (skip.isSet()) {
        obj.insert(QString("skip"), ::OpenAPI::toJsonValue(skip));
    }
    if (update.isSet()) {
        obj.insert(QString("update"), ::OpenAPI::toJsonValue(update));
    }
    if (updatelog.isSet()) {
        obj.insert(QString("updatelog"), ::OpenAPI::toJsonValue(updatelog));
    }
    if (users.isSet()) {
        obj.insert(QString("users"), ::OpenAPI::toJsonValue(users));
    }
    if (workflow.isSet()) {
        obj.insert(QString("workflow"), ::OpenAPI::toJsonValue(workflow));
    }
    if (zone.isSet()) {
        obj.insert(QString("zone"), ::OpenAPI::toJsonValue(zone));
    }
    return obj;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getAgents() const {
    return agents;
}
void OAINewUserRoleRequest_rights::setAgents(const OAIRolePermissionObject &agents) {
    this->agents = agents;
    this->m_agents_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getCert() const {
    return cert;
}
void OAINewUserRoleRequest_rights::setCert(const OAIRolePermissionObject &cert) {
    this->cert = cert;
    this->m_cert_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getConfiglog() const {
    return configlog;
}
void OAINewUserRoleRequest_rights::setConfiglog(const OAIRolePermissionObject &configlog) {
    this->configlog = configlog;
    this->m_configlog_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getEngines() const {
    return engines;
}
void OAINewUserRoleRequest_rights::setEngines(const OAIRolePermissionObject &engines) {
    this->engines = engines;
    this->m_engines_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getExternal() const {
    return external;
}
void OAINewUserRoleRequest_rights::setExternal(const OAIRolePermissionObject &external) {
    this->external = external;
    this->m_external_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getLicense() const {
    return license;
}
void OAINewUserRoleRequest_rights::setLicense(const OAIRolePermissionObject &license) {
    this->license = license;
    this->m_license_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getQuarantine() const {
    return quarantine;
}
void OAINewUserRoleRequest_rights::setQuarantine(const OAIRolePermissionObject &quarantine) {
    this->quarantine = quarantine;
    this->m_quarantine_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getRetention() const {
    return retention;
}
void OAINewUserRoleRequest_rights::setRetention(const OAIRolePermissionObject &retention) {
    this->retention = retention;
    this->m_retention_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getRule() const {
    return rule;
}
void OAINewUserRoleRequest_rights::setRule(const OAIRolePermissionObject &rule) {
    this->rule = rule;
    this->m_rule_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getScan() const {
    return scan;
}
void OAINewUserRoleRequest_rights::setScan(const OAIRolePermissionObject &scan) {
    this->scan = scan;
    this->m_scan_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getScanlog() const {
    return scanlog;
}
void OAINewUserRoleRequest_rights::setScanlog(const OAIRolePermissionObject &scanlog) {
    this->scanlog = scanlog;
    this->m_scanlog_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getSkip() const {
    return skip;
}
void OAINewUserRoleRequest_rights::setSkip(const OAIRolePermissionObject &skip) {
    this->skip = skip;
    this->m_skip_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getUpdate() const {
    return update;
}
void OAINewUserRoleRequest_rights::setUpdate(const OAIRolePermissionObject &update) {
    this->update = update;
    this->m_update_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getUpdatelog() const {
    return updatelog;
}
void OAINewUserRoleRequest_rights::setUpdatelog(const OAIRolePermissionObject &updatelog) {
    this->updatelog = updatelog;
    this->m_updatelog_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getUsers() const {
    return users;
}
void OAINewUserRoleRequest_rights::setUsers(const OAIRolePermissionObject &users) {
    this->users = users;
    this->m_users_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getWorkflow() const {
    return workflow;
}
void OAINewUserRoleRequest_rights::setWorkflow(const OAIRolePermissionObject &workflow) {
    this->workflow = workflow;
    this->m_workflow_isSet = true;
}

OAIRolePermissionObject OAINewUserRoleRequest_rights::getZone() const {
    return zone;
}
void OAINewUserRoleRequest_rights::setZone(const OAIRolePermissionObject &zone) {
    this->zone = zone;
    this->m_zone_isSet = true;
}

bool OAINewUserRoleRequest_rights::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (agents.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (cert.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (configlog.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (engines.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (external.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (license.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (quarantine.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (retention.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (rule.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (scan.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (scanlog.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (skip.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (update.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (updatelog.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (users.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (workflow.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (zone.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINewUserRoleRequest_rights::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
