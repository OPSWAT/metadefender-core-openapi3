/*
 * MetaDefender Core
 * ## Developer Guide This is the API documentation for *MetaDefender Core Public API*.  If you would like to evaluate or have any questions about this documentation, please contact us via our [Contact Us](https://opswat.com/contact) form.  ## How to Interact with MetaDefender Core using REST Beginning with MetaDefender Core 4.x, OPSWAT recommends using the JSON-based REST API. The available methods are documented below. > _**Note**:_ MetaDefender API doesn't support chunk upload, however is recommended to stream the files to MetaDefender as part of the upload process.  --- ## File Analysis Process    MetaDefender's main functionality is to analyze large volumes with a high throughput. Depending on the configuration and licensed technologies, the analysis times can vary.    Below is a brief description of the API integration flow:    1. Upload a file for analysis (`POST /file`), which returns the `data_id`: [File Analysis](#operation/fileAnalysisPost)).           > _**Note**:_ The performance depends on:           > - number of nodes (scaling)     > - number of engines per node     > - type of file to be scanned     > - Metadefender Core and nodes' hardware       2. You have 2 ways to retrieve the analysis report:      - **Polling**: Fetch the result with previously received data_id (`GET /file/{data_id}` resource) until scan result belonging to data_id doesn't reach the 100 percent progress_percentage: ( [Fetch processing result](#operation/userLogin))        > _**Note**:_ Too many data_id requests can reduce performance. It is enough to just check every few hundred milliseconds.          - **Callbackurl**: Specify a callbackurl that will be called once the analysis is complete.     3. Retrieve the analysis results anytime after the analysis is completed with hash for files (md5, sha1, sha256) by calling [Fetch processing result](#operation/userLogin).      - The hash can be found in the scan results    4. Retrieve processed file (sanitized, redacted, watermarked, etc.) after the analysis is complete.      > _**Note**:_ Based on the configured retention policy, the files might be available for retrieval at a later time.   --- OPSWAT provides some sample codes on [GitHub](https://github.com/OPSWAT) to make it easier to understand how the MetaDefender REST API works. 
 *
 * The version of the OpenAPI document: v4.18.0
 * Contact: feedback@opswat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AnalysisResult;
import java.io.File;
import org.openapitools.client.model.InlineResponse20010;
import org.openapitools.client.model.InlineResponse2008;
import org.openapitools.client.model.InlineResponse2009;
import org.openapitools.client.model.InlineResponse400;
import org.openapitools.client.model.InlineResponse500;
import java.net.URI;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AnalysisApi {
    private ApiClient localVarApiClient;

    public AnalysisApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AnalysisApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for analysisRules
     * @param userAgent The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the list of available rules. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call analysisRulesCall(String userAgent, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/file/rules";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (userAgent != null) {
            localVarHeaderParams.put("user_agent", localVarApiClient.parameterToString(userAgent));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call analysisRulesValidateBeforeCall(String userAgent, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = analysisRulesCall(userAgent, _callback);
        return localVarCall;

    }

    /**
     * Fetching Available Analysis Rules
     * Retrieve all available rules with their custom configurations. Fetching available processing rules. 
     * @param userAgent The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)
     * @return List&lt;InlineResponse20010&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the list of available rules. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public List<InlineResponse20010> analysisRules(String userAgent) throws ApiException {
        ApiResponse<List<InlineResponse20010>> localVarResp = analysisRulesWithHttpInfo(userAgent);
        return localVarResp.getData();
    }

    /**
     * Fetching Available Analysis Rules
     * Retrieve all available rules with their custom configurations. Fetching available processing rules. 
     * @param userAgent The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)
     * @return ApiResponse&lt;List&lt;InlineResponse20010&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the list of available rules. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<InlineResponse20010>> analysisRulesWithHttpInfo(String userAgent) throws ApiException {
        okhttp3.Call localVarCall = analysisRulesValidateBeforeCall(userAgent, null);
        Type localVarReturnType = new TypeToken<List<InlineResponse20010>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetching Available Analysis Rules (asynchronously)
     * Retrieve all available rules with their custom configurations. Fetching available processing rules. 
     * @param userAgent The user agent string value sent in the header (specified by the client).  Only those rules are returned, that:   * Match the client&#39;s user agent sent using the user_agent header, or   * Are not restricted to a specific user agent.  For details see KB article [What are Security Policies and how do I use them?](https://onlinehelp.opswat.com/corev4/What_are_Security_Policies_and_how_do_I_use_them_.html).  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the list of available rules. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call analysisRulesAsync(String userAgent, final ApiCallback<List<InlineResponse20010>> _callback) throws ApiException {

        okhttp3.Call localVarCall = analysisRulesValidateBeforeCall(userAgent, _callback);
        Type localVarReturnType = new TypeToken<List<InlineResponse20010>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fileAnalysisCancel
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Analysis was successfully cancelled. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileAnalysisCancelCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/file/{data_id}/cancel"
            .replaceAll("\\{" + "data_id" + "\\}", localVarApiClient.escapeString(dataId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (apikey != null) {
            localVarHeaderParams.put("apikey", localVarApiClient.parameterToString(apikey));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fileAnalysisCancelValidateBeforeCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'dataId' is set
        if (dataId == null) {
            throw new ApiException("Missing the required parameter 'dataId' when calling fileAnalysisCancel(Async)");
        }
        

        okhttp3.Call localVarCall = fileAnalysisCancelCall(dataId, apikey, _callback);
        return localVarCall;

    }

    /**
     * Cancel File Analysis
     * When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Analysis was successfully cancelled. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public Object fileAnalysisCancel(String dataId, String apikey) throws ApiException {
        ApiResponse<Object> localVarResp = fileAnalysisCancelWithHttpInfo(dataId, apikey);
        return localVarResp.getData();
    }

    /**
     * Cancel File Analysis
     * When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Analysis was successfully cancelled. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> fileAnalysisCancelWithHttpInfo(String dataId, String apikey) throws ApiException {
        okhttp3.Call localVarCall = fileAnalysisCancelValidateBeforeCall(dataId, apikey, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel File Analysis (asynchronously)
     * When cancelling a file analysis, the connected analysis (e.g. files in an archive) that are still in progress will be cancelled also.   The cancelled analysis will be automatically closed. 
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Analysis was successfully cancelled. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileAnalysisCancelAsync(String dataId, String apikey, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = fileAnalysisCancelValidateBeforeCall(dataId, apikey, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fileAnalysisGet
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Entire analysis report generated by MetaDefender </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileAnalysisGetCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/file/{data_id}"
            .replaceAll("\\{" + "data_id" + "\\}", localVarApiClient.escapeString(dataId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (apikey != null) {
            localVarHeaderParams.put("apikey", localVarApiClient.parameterToString(apikey));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fileAnalysisGetValidateBeforeCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'dataId' is set
        if (dataId == null) {
            throw new ApiException("Missing the required parameter 'dataId' when calling fileAnalysisGet(Async)");
        }
        

        okhttp3.Call localVarCall = fileAnalysisGetCall(dataId, apikey, _callback);
        return localVarCall;

    }

    /**
     * Fetch Analysis Result
     * Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return AnalysisResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Entire analysis report generated by MetaDefender </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public AnalysisResult fileAnalysisGet(String dataId, String apikey) throws ApiException {
        ApiResponse<AnalysisResult> localVarResp = fileAnalysisGetWithHttpInfo(dataId, apikey);
        return localVarResp.getData();
    }

    /**
     * Fetch Analysis Result
     * Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return ApiResponse&lt;AnalysisResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Entire analysis report generated by MetaDefender </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AnalysisResult> fileAnalysisGetWithHttpInfo(String dataId, String apikey) throws ApiException {
        okhttp3.Call localVarCall = fileAnalysisGetValidateBeforeCall(dataId, apikey, null);
        Type localVarReturnType = new TypeToken<AnalysisResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetch Analysis Result (asynchronously)
     * Retrieve scan results. Scan is done asynchronously and each scan request is tracked by a data ID. Initiating file scans and retrieving the results need to be done using two separate API calls. This request needs to be made multiple times until the scan is complete. Scan completion can be traced using &#x60;scan_results.progress_percentage&#x60; value from the response. 
     * @param dataId  (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Entire analysis report generated by MetaDefender </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileAnalysisGetAsync(String dataId, String apikey, final ApiCallback<AnalysisResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = fileAnalysisGetValidateBeforeCall(dataId, apikey, _callback);
        Type localVarReturnType = new TypeToken<AnalysisResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fileAnalysisPost
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param filename The name of the submitted file (optional)
     * @param filepath if local file scan is enabled the path to the file (see Security rule configuration) (optional)
     * @param userAgent user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)
     * @param rule Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)
     * @param workflow name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)
     * @param batch Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)
     * @param archivepwd password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)
     * @param metadata could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)
     * @param callbackurl Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)
     * @param body  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful file submission </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Callbackurl and/or apikey is invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 411 </td><td> Content-Length header is missing from the request. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Body input is empty. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Server is too busy, scan queue is full. Try again later. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileAnalysisPostCall(String apikey, String filename, String filepath, String userAgent, String rule, String workflow, String batch, String archivepwd, String metadata, URI callbackurl, File body, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/file";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (apikey != null) {
            localVarHeaderParams.put("apikey", localVarApiClient.parameterToString(apikey));
        }

        if (filename != null) {
            localVarHeaderParams.put("filename", localVarApiClient.parameterToString(filename));
        }

        if (filepath != null) {
            localVarHeaderParams.put("filepath", localVarApiClient.parameterToString(filepath));
        }

        if (userAgent != null) {
            localVarHeaderParams.put("user_agent", localVarApiClient.parameterToString(userAgent));
        }

        if (rule != null) {
            localVarHeaderParams.put("rule", localVarApiClient.parameterToString(rule));
        }

        if (workflow != null) {
            localVarHeaderParams.put("workflow", localVarApiClient.parameterToString(workflow));
        }

        if (batch != null) {
            localVarHeaderParams.put("batch", localVarApiClient.parameterToString(batch));
        }

        if (archivepwd != null) {
            localVarHeaderParams.put("archivepwd", localVarApiClient.parameterToString(archivepwd));
        }

        if (metadata != null) {
            localVarHeaderParams.put("metadata", localVarApiClient.parameterToString(metadata));
        }

        if (callbackurl != null) {
            localVarHeaderParams.put("callbackurl", localVarApiClient.parameterToString(callbackurl));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/octet-stream"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fileAnalysisPostValidateBeforeCall(String apikey, String filename, String filepath, String userAgent, String rule, String workflow, String batch, String archivepwd, String metadata, URI callbackurl, File body, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = fileAnalysisPostCall(apikey, filename, filepath, userAgent, rule, workflow, batch, archivepwd, metadata, callbackurl, body, _callback);
        return localVarCall;

    }

    /**
     * Analyze File
     * ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param filename The name of the submitted file (optional)
     * @param filepath if local file scan is enabled the path to the file (see Security rule configuration) (optional)
     * @param userAgent user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)
     * @param rule Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)
     * @param workflow name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)
     * @param batch Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)
     * @param archivepwd password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)
     * @param metadata could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)
     * @param callbackurl Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)
     * @param body  (optional)
     * @return InlineResponse2008
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful file submission </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Callbackurl and/or apikey is invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 411 </td><td> Content-Length header is missing from the request. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Body input is empty. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Server is too busy, scan queue is full. Try again later. </td><td>  -  </td></tr>
     </table>
     */
    public InlineResponse2008 fileAnalysisPost(String apikey, String filename, String filepath, String userAgent, String rule, String workflow, String batch, String archivepwd, String metadata, URI callbackurl, File body) throws ApiException {
        ApiResponse<InlineResponse2008> localVarResp = fileAnalysisPostWithHttpInfo(apikey, filename, filepath, userAgent, rule, workflow, batch, archivepwd, metadata, callbackurl, body);
        return localVarResp.getData();
    }

    /**
     * Analyze File
     * ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param filename The name of the submitted file (optional)
     * @param filepath if local file scan is enabled the path to the file (see Security rule configuration) (optional)
     * @param userAgent user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)
     * @param rule Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)
     * @param workflow name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)
     * @param batch Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)
     * @param archivepwd password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)
     * @param metadata could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)
     * @param callbackurl Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)
     * @param body  (optional)
     * @return ApiResponse&lt;InlineResponse2008&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful file submission </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Callbackurl and/or apikey is invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 411 </td><td> Content-Length header is missing from the request. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Body input is empty. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Server is too busy, scan queue is full. Try again later. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<InlineResponse2008> fileAnalysisPostWithHttpInfo(String apikey, String filename, String filepath, String userAgent, String rule, String workflow, String batch, String archivepwd, String metadata, URI callbackurl, File body) throws ApiException {
        okhttp3.Call localVarCall = fileAnalysisPostValidateBeforeCall(apikey, filename, filepath, userAgent, rule, workflow, batch, archivepwd, metadata, callbackurl, body, null);
        Type localVarReturnType = new TypeToken<InlineResponse2008>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Analyze File (asynchronously)
     * ## Scanning a file using a specified workflow. Scan is done asynchronously and each scan request is tracked by data id of which result can be retrieved by API Fetch Scan Result. &gt; _**Note**_: Chunked transfer encoding (applying header Transfer-Encoding: Chunked) is **not supported** on &#x60;/file&#x60; API.
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param filename The name of the submitted file (optional)
     * @param filepath if local file scan is enabled the path to the file (see Security rule configuration) (optional)
     * @param userAgent user_agent header used to identify (and limit) access to a particular rule. For rule selection, &#x60;rule&#x60; header should be used.  (optional)
     * @param rule Select rule for the analysis, if no header given the default rule will be selected (URL encoded string of rule name)        (optional)
     * @param workflow name of the selected workflow (deprecated, use \&quot;rule\&quot; header parameter instead) (optional)
     * @param batch Batch id to scan with, coming from &#x60;Initiate Batch&#x60; (If it is not given, it will be a single file scan.) (optional)
     * @param archivepwd password for archive ( URL encoded UTF-8 string)   Multiple passwords is also supported, format: archivepwd&lt;X&gt;     * X: Could be empty     * When having value, X must be a number &gt;&#x3D; 1   For example:     archivepwd1: \&quot;fox\&quot;     archivepwd2: \&quot;cow\&quot;     archivepwd3: \&quot;bear\&quot;  (optional)
     * @param metadata could be utilized for: Additional parameter for pre-defined post actions and external scanners (as a part of STDIN input). Customized macro variable for watermarking text (Proactive DLP engine feature). Additional context / verbose information for each file submission (appended into JSON response scan result).  (optional)
     * @param callbackurl Client&#39;s URL where MetaDefender Core will notify scan result back to whenever scan is finished (webhooks model). See details at 8.1.11.1. Individual file processing   * Format: &lt;protocol://&gt;&lt;ip | domain&gt;:&lt;port&gt;&lt;/path&gt;   * Example: http://10.0.1.100:8081/listenback  (optional)
     * @param body  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful file submission </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Callbackurl and/or apikey is invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 411 </td><td> Content-Length header is missing from the request. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Body input is empty. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Server is too busy, scan queue is full. Try again later. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileAnalysisPostAsync(String apikey, String filename, String filepath, String userAgent, String rule, String workflow, String batch, String archivepwd, String metadata, URI callbackurl, File body, final ApiCallback<InlineResponse2008> _callback) throws ApiException {

        okhttp3.Call localVarCall = fileAnalysisPostValidateBeforeCall(apikey, filename, filepath, userAgent, rule, workflow, batch, archivepwd, metadata, callbackurl, body, _callback);
        Type localVarReturnType = new TypeToken<InlineResponse2008>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for sanitizedFile
     * @param dataId The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the sanitized content. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sanitizedFileCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/file/converted/{data_id}"
            .replaceAll("\\{" + "data_id" + "\\}", localVarApiClient.escapeString(dataId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (apikey != null) {
            localVarHeaderParams.put("apikey", localVarApiClient.parameterToString(apikey));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/octet-stream", "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sanitizedFileValidateBeforeCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'dataId' is set
        if (dataId == null) {
            throw new ApiException("Missing the required parameter 'dataId' when calling sanitizedFile(Async)");
        }
        

        okhttp3.Call localVarCall = sanitizedFileCall(dataId, apikey, _callback);
        return localVarCall;

    }

    /**
     * Download Sanitized Files
     * Retrieve sanitized file based on the &#x60;data_id&#x60; 
     * @param dataId The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the sanitized content. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public File sanitizedFile(String dataId, String apikey) throws ApiException {
        ApiResponse<File> localVarResp = sanitizedFileWithHttpInfo(dataId, apikey);
        return localVarResp.getData();
    }

    /**
     * Download Sanitized Files
     * Retrieve sanitized file based on the &#x60;data_id&#x60; 
     * @param dataId The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the sanitized content. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> sanitizedFileWithHttpInfo(String dataId, String apikey) throws ApiException {
        okhttp3.Call localVarCall = sanitizedFileValidateBeforeCall(dataId, apikey, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Download Sanitized Files (asynchronously)
     * Retrieve sanitized file based on the &#x60;data_id&#x60; 
     * @param dataId The data_id comes from the result of &#x60;Analyze a file&#x60;. In case of sanitizing the content of an archive, the data_id of contained file can be found in &#x60;Fetch analysis result&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the sanitized content. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> The user has no rights for this operation. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call sanitizedFileAsync(String dataId, String apikey, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = sanitizedFileValidateBeforeCall(dataId, apikey, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for webhookStatus
     * @param dataId Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Webhooks status is fetched successfully. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call webhookStatusCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/file/webhook/{data_id}"
            .replaceAll("\\{" + "data_id" + "\\}", localVarApiClient.escapeString(dataId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (apikey != null) {
            localVarHeaderParams.put("apikey", localVarApiClient.parameterToString(apikey));
        }

        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call webhookStatusValidateBeforeCall(String dataId, String apikey, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'dataId' is set
        if (dataId == null) {
            throw new ApiException("Missing the required parameter 'dataId' when calling webhookStatus(Async)");
        }
        

        okhttp3.Call localVarCall = webhookStatusCall(dataId, apikey, _callback);
        return localVarCall;

    }

    /**
     * Query webhook status
     * Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
     * @param dataId Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return InlineResponse2009
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Webhooks status is fetched successfully. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public InlineResponse2009 webhookStatus(String dataId, String apikey) throws ApiException {
        ApiResponse<InlineResponse2009> localVarResp = webhookStatusWithHttpInfo(dataId, apikey);
        return localVarResp.getData();
    }

    /**
     * Query webhook status
     * Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
     * @param dataId Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @return ApiResponse&lt;InlineResponse2009&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Webhooks status is fetched successfully. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<InlineResponse2009> webhookStatusWithHttpInfo(String dataId, String apikey) throws ApiException {
        okhttp3.Call localVarCall = webhookStatusValidateBeforeCall(dataId, apikey, null);
        Type localVarReturnType = new TypeToken<InlineResponse2009>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Query webhook status (asynchronously)
     * Prior to being notified by Core when webhooks mode is set, client can anytime ask Core for file / batch processing webhooks status. 
     * @param dataId Either &#x60;data_id&#x60; or &#x60;batch_id&#x60;. (required)
     * @param apikey Generated &#x60;session_id&#x60; from [Login](#operation/userLogin) call can be used as an &#x60;apikey&#x60; for API calls that require authentication.                 (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Webhooks status is fetched successfully. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request (e.g. invalid header, apikey is missing or invalid). </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Invalid user information or Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Requests resource was not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Unexpected event on server </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call webhookStatusAsync(String dataId, String apikey, final ApiCallback<InlineResponse2009> _callback) throws ApiException {

        okhttp3.Call localVarCall = webhookStatusValidateBeforeCall(dataId, apikey, _callback);
        Type localVarReturnType = new TypeToken<InlineResponse2009>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
