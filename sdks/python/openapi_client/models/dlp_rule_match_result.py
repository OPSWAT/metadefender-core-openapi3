# coding: utf-8

"""
    MetaDefender Core

    ## Developer Guide This is the API documentation for *MetaDefender Core Public API*.  If you would like to evaluate or have any questions about this documentation, please contact us via our [Contact Us](https://opswat.com/contact) form.  ## How to Interact with MetaDefender Core using REST Beginning with MetaDefender Core 4.x, OPSWAT recommends using the JSON-based REST API. The available methods are documented below. > _**Note**:_ MetaDefender API doesn't support chunk upload, however is recommended to stream the files to MetaDefender as part of the upload process.  --- ## File Analysis Process    MetaDefender's main functionality is to analyze large volumes with a high throughput. Depending on the configuration and licensed technologies, the analysis times can vary.    Below is a brief description of the API integration flow:    1. Upload a file for analysis (`POST /file`), which returns the `data_id`: [File Analysis](#operation/fileAnalysisPost)).           > _**Note**:_ The performance depends on:           > - number of nodes (scaling)     > - number of engines per node     > - type of file to be scanned     > - Metadefender Core and nodes' hardware       2. You have 2 ways to retrieve the analysis report:      - **Polling**: Fetch the result with previously received data_id (`GET /file/{data_id}` resource) until scan result belonging to data_id doesn't reach the 100 percent progress_percentage: ( [Fetch processing result](#operation/userLogin))        > _**Note**:_ Too many data_id requests can reduce performance. It is enough to just check every few hundred milliseconds.          - **Callbackurl**: Specify a callbackurl that will be called once the analysis is complete.     3. Retrieve the analysis results anytime after the analysis is completed with hash for files (md5, sha1, sha256) by calling [Fetch processing result](#operation/userLogin).      - The hash can be found in the scan results    4. Retrieve processed file (sanitized, redacted, watermarked, etc.) after the analysis is complete.      > _**Note**:_ Based on the configured retention policy, the files might be available for retrieval at a later time.   --- OPSWAT provides some sample codes on [GitHub](https://github.com/OPSWAT) to make it easier to understand how the MetaDefender REST API works.   # noqa: E501

    The version of the OpenAPI document: v4.18.0
    Contact: feedback@opswat.com
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from openapi_client.configuration import Configuration


class DLPRuleMatchResult(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'after': 'str',
        'before': 'str',
        'certainty': 'str',
        'certainty_score': 'int',
        'hit': 'str',
        'is_redacted': 'bool',
        'severity': 'int'
    }

    attribute_map = {
        'after': 'after',
        'before': 'before',
        'certainty': 'certainty',
        'certainty_score': 'certainty_score',
        'hit': 'hit',
        'is_redacted': 'isRedacted',
        'severity': 'severity'
    }

    def __init__(self, after=None, before=None, certainty=None, certainty_score=None, hit=None, is_redacted=None, severity=None, local_vars_configuration=None):  # noqa: E501
        """DLPRuleMatchResult - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._after = None
        self._before = None
        self._certainty = None
        self._certainty_score = None
        self._hit = None
        self._is_redacted = None
        self._severity = None
        self.discriminator = None

        if after is not None:
            self.after = after
        if before is not None:
            self.before = before
        if certainty is not None:
            self.certainty = certainty
        if certainty_score is not None:
            self.certainty_score = certainty_score
        if hit is not None:
            self.hit = hit
        if is_redacted is not None:
            self.is_redacted = is_redacted
        if severity is not None:
            self.severity = severity

    @property
    def after(self):
        """Gets the after of this DLPRuleMatchResult.  # noqa: E501

        The context after the matched data.  # noqa: E501

        :return: The after of this DLPRuleMatchResult.  # noqa: E501
        :rtype: str
        """
        return self._after

    @after.setter
    def after(self, after):
        """Sets the after of this DLPRuleMatchResult.

        The context after the matched data.  # noqa: E501

        :param after: The after of this DLPRuleMatchResult.  # noqa: E501
        :type: str
        """

        self._after = after

    @property
    def before(self):
        """Gets the before of this DLPRuleMatchResult.  # noqa: E501

        The context before the matched data.  # noqa: E501

        :return: The before of this DLPRuleMatchResult.  # noqa: E501
        :rtype: str
        """
        return self._before

    @before.setter
    def before(self, before):
        """Sets the before of this DLPRuleMatchResult.

        The context before the matched data.  # noqa: E501

        :param before: The before of this DLPRuleMatchResult.  # noqa: E501
        :type: str
        """

        self._before = before

    @property
    def certainty(self):
        """Gets the certainty of this DLPRuleMatchResult.  # noqa: E501

        The text version of \"certainty_score\", possible values:   * `Very Low`     * `Low`     * `Medium`     * `High`     * `Very High`   # noqa: E501

        :return: The certainty of this DLPRuleMatchResult.  # noqa: E501
        :rtype: str
        """
        return self._certainty

    @certainty.setter
    def certainty(self, certainty):
        """Sets the certainty of this DLPRuleMatchResult.

        The text version of \"certainty_score\", possible values:   * `Very Low`     * `Low`     * `Medium`     * `High`     * `Very High`   # noqa: E501

        :param certainty: The certainty of this DLPRuleMatchResult.  # noqa: E501
        :type: str
        """
        allowed_values = ["Very Low", "Low", "Medium", "High", "Very High"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and certainty not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `certainty` ({0}), must be one of {1}"  # noqa: E501
                .format(certainty, allowed_values)
            )

        self._certainty = certainty

    @property
    def certainty_score(self):
        """Gets the certainty_score of this DLPRuleMatchResult.  # noqa: E501

        Is  defined by the relevance of the given hit in its context. It is calculated based on multiple factors such as the number of digits, possible values: [0-100]   # noqa: E501

        :return: The certainty_score of this DLPRuleMatchResult.  # noqa: E501
        :rtype: int
        """
        return self._certainty_score

    @certainty_score.setter
    def certainty_score(self, certainty_score):
        """Sets the certainty_score of this DLPRuleMatchResult.

        Is  defined by the relevance of the given hit in its context. It is calculated based on multiple factors such as the number of digits, possible values: [0-100]   # noqa: E501

        :param certainty_score: The certainty_score of this DLPRuleMatchResult.  # noqa: E501
        :type: int
        """

        self._certainty_score = certainty_score

    @property
    def hit(self):
        """Gets the hit of this DLPRuleMatchResult.  # noqa: E501

        The matched data.  # noqa: E501

        :return: The hit of this DLPRuleMatchResult.  # noqa: E501
        :rtype: str
        """
        return self._hit

    @hit.setter
    def hit(self, hit):
        """Sets the hit of this DLPRuleMatchResult.

        The matched data.  # noqa: E501

        :param hit: The hit of this DLPRuleMatchResult.  # noqa: E501
        :type: str
        """

        self._hit = hit

    @property
    def is_redacted(self):
        """Gets the is_redacted of this DLPRuleMatchResult.  # noqa: E501

        If file was redacted or not.  # noqa: E501

        :return: The is_redacted of this DLPRuleMatchResult.  # noqa: E501
        :rtype: bool
        """
        return self._is_redacted

    @is_redacted.setter
    def is_redacted(self, is_redacted):
        """Sets the is_redacted of this DLPRuleMatchResult.

        If file was redacted or not.  # noqa: E501

        :param is_redacted: The is_redacted of this DLPRuleMatchResult.  # noqa: E501
        :type: bool
        """

        self._is_redacted = is_redacted

    @property
    def severity(self):
        """Gets the severity of this DLPRuleMatchResult.  # noqa: E501

        (NOTE: this field is deprecated): can be 0 (detected) or 1 (suspicious).   # noqa: E501

        :return: The severity of this DLPRuleMatchResult.  # noqa: E501
        :rtype: int
        """
        return self._severity

    @severity.setter
    def severity(self, severity):
        """Sets the severity of this DLPRuleMatchResult.

        (NOTE: this field is deprecated): can be 0 (detected) or 1 (suspicious).   # noqa: E501

        :param severity: The severity of this DLPRuleMatchResult.  # noqa: E501
        :type: int
        """
        allowed_values = [0, 1]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and severity not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `severity` ({0}), must be one of {1}"  # noqa: E501
                .format(severity, allowed_values)
            )

        self._severity = severity

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DLPRuleMatchResult):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, DLPRuleMatchResult):
            return True

        return self.to_dict() != other.to_dict()
