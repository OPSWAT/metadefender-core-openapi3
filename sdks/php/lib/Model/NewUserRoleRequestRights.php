<?php
/**
 * NewUserRoleRequestRights
 *
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MetaDefender Core
 *
 * ## Developer Guide This is the API documentation for *MetaDefender Core Public API*.  If you would like to evaluate or have any questions about this documentation, please contact us via our [Contact Us](https://opswat.com/contact) form.  ## How to Interact with MetaDefender Core using REST Beginning with MetaDefender Core 4.x, OPSWAT recommends using the JSON-based REST API. The available methods are documented below. > _**Note**:_ MetaDefender API doesn't support chunk upload, however is recommended to stream the files to MetaDefender as part of the upload process.  --- ## File Analysis Process    MetaDefender's main functionality is to analyze large volumes with a high throughput. Depending on the configuration and licensed technologies, the analysis times can vary.    Below is a brief description of the API integration flow:    1. Upload a file for analysis (`POST /file`), which returns the `data_id`: [File Analysis](#operation/fileAnalysisPost)).           > _**Note**:_ The performance depends on:           > - number of nodes (scaling)     > - number of engines per node     > - type of file to be scanned     > - Metadefender Core and nodes' hardware       2. You have 2 ways to retrieve the analysis report:      - **Polling**: Fetch the result with previously received data_id (`GET /file/{data_id}` resource) until scan result belonging to data_id doesn't reach the 100 percent progress_percentage: ( [Fetch processing result](#operation/userLogin))        > _**Note**:_ Too many data_id requests can reduce performance. It is enough to just check every few hundred milliseconds.          - **Callbackurl**: Specify a callbackurl that will be called once the analysis is complete.     3. Retrieve the analysis results anytime after the analysis is completed with hash for files (md5, sha1, sha256) by calling [Fetch processing result](#operation/userLogin).      - The hash can be found in the scan results    4. Retrieve processed file (sanitized, redacted, watermarked, etc.) after the analysis is complete.      > _**Note**:_ Based on the configured retention policy, the files might be available for retrieval at a later time.   --- OPSWAT provides some sample codes on [GitHub](https://github.com/OPSWAT) to make it easier to understand how the MetaDefender REST API works.
 *
 * The version of the OpenAPI document: v4.18.0
 * Contact: feedback@opswat.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * NewUserRoleRequestRights Class Doc Comment
 *
 * @category Class
 * @description A list of rights for each permission
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NewUserRoleRequestRights implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'NewUserRoleRequest_rights';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'agents' => 'RolePermissionObject',
        'cert' => 'RolePermissionObject',
        'configlog' => 'RolePermissionObject',
        'engines' => 'RolePermissionObject',
        'external' => 'RolePermissionObject',
        'license' => 'RolePermissionObject',
        'quarantine' => 'RolePermissionObject',
        'retention' => 'RolePermissionObject',
        'rule' => 'RolePermissionObject',
        'scan' => 'RolePermissionObject',
        'scanlog' => 'RolePermissionObject',
        'skip' => 'RolePermissionObject',
        'update' => 'RolePermissionObject',
        'updatelog' => 'RolePermissionObject',
        'users' => 'RolePermissionObject',
        'workflow' => 'RolePermissionObject',
        'zone' => 'RolePermissionObject'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'agents' => null,
        'cert' => null,
        'configlog' => null,
        'engines' => null,
        'external' => null,
        'license' => null,
        'quarantine' => null,
        'retention' => null,
        'rule' => null,
        'scan' => null,
        'scanlog' => null,
        'skip' => null,
        'update' => null,
        'updatelog' => null,
        'users' => null,
        'workflow' => null,
        'zone' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'agents' => 'agents',
        'cert' => 'cert',
        'configlog' => 'configlog',
        'engines' => 'engines',
        'external' => 'external',
        'license' => 'license',
        'quarantine' => 'quarantine',
        'retention' => 'retention',
        'rule' => 'rule',
        'scan' => 'scan',
        'scanlog' => 'scanlog',
        'skip' => 'skip',
        'update' => 'update',
        'updatelog' => 'updatelog',
        'users' => 'users',
        'workflow' => 'workflow',
        'zone' => 'zone'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'agents' => 'setAgents',
        'cert' => 'setCert',
        'configlog' => 'setConfiglog',
        'engines' => 'setEngines',
        'external' => 'setExternal',
        'license' => 'setLicense',
        'quarantine' => 'setQuarantine',
        'retention' => 'setRetention',
        'rule' => 'setRule',
        'scan' => 'setScan',
        'scanlog' => 'setScanlog',
        'skip' => 'setSkip',
        'update' => 'setUpdate',
        'updatelog' => 'setUpdatelog',
        'users' => 'setUsers',
        'workflow' => 'setWorkflow',
        'zone' => 'setZone'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'agents' => 'getAgents',
        'cert' => 'getCert',
        'configlog' => 'getConfiglog',
        'engines' => 'getEngines',
        'external' => 'getExternal',
        'license' => 'getLicense',
        'quarantine' => 'getQuarantine',
        'retention' => 'getRetention',
        'rule' => 'getRule',
        'scan' => 'getScan',
        'scanlog' => 'getScanlog',
        'skip' => 'getSkip',
        'update' => 'getUpdate',
        'updatelog' => 'getUpdatelog',
        'users' => 'getUsers',
        'workflow' => 'getWorkflow',
        'zone' => 'getZone'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['agents'] = isset($data['agents']) ? $data['agents'] : null;
        $this->container['cert'] = isset($data['cert']) ? $data['cert'] : null;
        $this->container['configlog'] = isset($data['configlog']) ? $data['configlog'] : null;
        $this->container['engines'] = isset($data['engines']) ? $data['engines'] : null;
        $this->container['external'] = isset($data['external']) ? $data['external'] : null;
        $this->container['license'] = isset($data['license']) ? $data['license'] : null;
        $this->container['quarantine'] = isset($data['quarantine']) ? $data['quarantine'] : null;
        $this->container['retention'] = isset($data['retention']) ? $data['retention'] : null;
        $this->container['rule'] = isset($data['rule']) ? $data['rule'] : null;
        $this->container['scan'] = isset($data['scan']) ? $data['scan'] : null;
        $this->container['scanlog'] = isset($data['scanlog']) ? $data['scanlog'] : null;
        $this->container['skip'] = isset($data['skip']) ? $data['skip'] : null;
        $this->container['update'] = isset($data['update']) ? $data['update'] : null;
        $this->container['updatelog'] = isset($data['updatelog']) ? $data['updatelog'] : null;
        $this->container['users'] = isset($data['users']) ? $data['users'] : null;
        $this->container['workflow'] = isset($data['workflow']) ? $data['workflow'] : null;
        $this->container['zone'] = isset($data['zone']) ? $data['zone'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets agents
     *
     * @return RolePermissionObject|null
     */
    public function getAgents()
    {
        return $this->container['agents'];
    }

    /**
     * Sets agents
     *
     * @param RolePermissionObject|null $agents What permissions are allowed for Node.
     *
     * @return $this
     */
    public function setAgents($agents)
    {
        $this->container['agents'] = $agents;

        return $this;
    }

    /**
     * Gets cert
     *
     * @return RolePermissionObject|null
     */
    public function getCert()
    {
        return $this->container['cert'];
    }

    /**
     * Sets cert
     *
     * @param RolePermissionObject|null $cert What permissions are allowed for Certificates.
     *
     * @return $this
     */
    public function setCert($cert)
    {
        $this->container['cert'] = $cert;

        return $this;
    }

    /**
     * Gets configlog
     *
     * @return RolePermissionObject|null
     */
    public function getConfiglog()
    {
        return $this->container['configlog'];
    }

    /**
     * Sets configlog
     *
     * @param RolePermissionObject|null $configlog What permissions are allowed for Configuration logs.
     *
     * @return $this
     */
    public function setConfiglog($configlog)
    {
        $this->container['configlog'] = $configlog;

        return $this;
    }

    /**
     * Gets engines
     *
     * @return RolePermissionObject|null
     */
    public function getEngines()
    {
        return $this->container['engines'];
    }

    /**
     * Sets engines
     *
     * @param RolePermissionObject|null $engines What permissions are allowed for Engines and Modules.
     *
     * @return $this
     */
    public function setEngines($engines)
    {
        $this->container['engines'] = $engines;

        return $this;
    }

    /**
     * Gets external
     *
     * @return RolePermissionObject|null
     */
    public function getExternal()
    {
        return $this->container['external'];
    }

    /**
     * Sets external
     *
     * @param RolePermissionObject|null $external What permissions are allowed for External actions (External Scanner/Post Actions).
     *
     * @return $this
     */
    public function setExternal($external)
    {
        $this->container['external'] = $external;

        return $this;
    }

    /**
     * Gets license
     *
     * @return RolePermissionObject|null
     */
    public function getLicense()
    {
        return $this->container['license'];
    }

    /**
     * Sets license
     *
     * @param RolePermissionObject|null $license What permissions are allowed for managing the License.
     *
     * @return $this
     */
    public function setLicense($license)
    {
        $this->container['license'] = $license;

        return $this;
    }

    /**
     * Gets quarantine
     *
     * @return RolePermissionObject|null
     */
    public function getQuarantine()
    {
        return $this->container['quarantine'];
    }

    /**
     * Sets quarantine
     *
     * @param RolePermissionObject|null $quarantine What permissions are allowed for managing the Quarantine.
     *
     * @return $this
     */
    public function setQuarantine($quarantine)
    {
        $this->container['quarantine'] = $quarantine;

        return $this;
    }

    /**
     * Gets retention
     *
     * @return RolePermissionObject|null
     */
    public function getRetention()
    {
        return $this->container['retention'];
    }

    /**
     * Sets retention
     *
     * @param RolePermissionObject|null $retention What permissions are allowed for managing the retention policies.
     *
     * @return $this
     */
    public function setRetention($retention)
    {
        $this->container['retention'] = $retention;

        return $this;
    }

    /**
     * Gets rule
     *
     * @return RolePermissionObject|null
     */
    public function getRule()
    {
        return $this->container['rule'];
    }

    /**
     * Sets rule
     *
     * @param RolePermissionObject|null $rule What permissions are allowed for managing the workflow rules.
     *
     * @return $this
     */
    public function setRule($rule)
    {
        $this->container['rule'] = $rule;

        return $this;
    }

    /**
     * Gets scan
     *
     * @return RolePermissionObject|null
     */
    public function getScan()
    {
        return $this->container['scan'];
    }

    /**
     * Sets scan
     *
     * @param RolePermissionObject|null $scan What permissions are allowed for managing analysis actions.
     *
     * @return $this
     */
    public function setScan($scan)
    {
        $this->container['scan'] = $scan;

        return $this;
    }

    /**
     * Gets scanlog
     *
     * @return RolePermissionObject|null
     */
    public function getScanlog()
    {
        return $this->container['scanlog'];
    }

    /**
     * Sets scanlog
     *
     * @param RolePermissionObject|null $scanlog What permissions are allowed for managing the analysis logs.
     *
     * @return $this
     */
    public function setScanlog($scanlog)
    {
        $this->container['scanlog'] = $scanlog;

        return $this;
    }

    /**
     * Gets skip
     *
     * @return RolePermissionObject|null
     */
    public function getSkip()
    {
        return $this->container['skip'];
    }

    /**
     * Sets skip
     *
     * @param RolePermissionObject|null $skip What permissions are allowed for managing the Whitelist/blacklist defined in the Inventory.
     *
     * @return $this
     */
    public function setSkip($skip)
    {
        $this->container['skip'] = $skip;

        return $this;
    }

    /**
     * Gets update
     *
     * @return RolePermissionObject|null
     */
    public function getUpdate()
    {
        return $this->container['update'];
    }

    /**
     * Sets update
     *
     * @param RolePermissionObject|null $update What permissions are allowed for managing the update configuration.
     *
     * @return $this
     */
    public function setUpdate($update)
    {
        $this->container['update'] = $update;

        return $this;
    }

    /**
     * Gets updatelog
     *
     * @return RolePermissionObject|null
     */
    public function getUpdatelog()
    {
        return $this->container['updatelog'];
    }

    /**
     * Sets updatelog
     *
     * @param RolePermissionObject|null $updatelog What permissions are allowed for managing the update logs.
     *
     * @return $this
     */
    public function setUpdatelog($updatelog)
    {
        $this->container['updatelog'] = $updatelog;

        return $this;
    }

    /**
     * Gets users
     *
     * @return RolePermissionObject|null
     */
    public function getUsers()
    {
        return $this->container['users'];
    }

    /**
     * Sets users
     *
     * @param RolePermissionObject|null $users What permissions are allowed for managing the users.
     *
     * @return $this
     */
    public function setUsers($users)
    {
        $this->container['users'] = $users;

        return $this;
    }

    /**
     * Gets workflow
     *
     * @return RolePermissionObject|null
     */
    public function getWorkflow()
    {
        return $this->container['workflow'];
    }

    /**
     * Sets workflow
     *
     * @param RolePermissionObject|null $workflow What permissions are allowed for managing the workflow templates.
     *
     * @return $this
     */
    public function setWorkflow($workflow)
    {
        $this->container['workflow'] = $workflow;

        return $this;
    }

    /**
     * Gets zone
     *
     * @return RolePermissionObject|null
     */
    public function getZone()
    {
        return $this->container['zone'];
    }

    /**
     * Sets zone
     *
     * @param RolePermissionObject|null $zone What permissions are allowed for managing the network zones.
     *
     * @return $this
     */
    public function setZone($zone)
    {
        $this->container['zone'] = $zone;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


